*Collection Framework:-
means A redimate architecture or predefine classes.a collection is the simply and object that groups multiple elements or object in to 
single unit. collection are used to store,retrive and manipulate data to transmited data from one method to another method.
*Advantages of collection framework:-
i>interoperability betn unreleted API's.
ii>Reduced the effort required to learn API's.
iii>Reduced the effort required to design & implemented API's & faster s/w reused.
  Collction framework provides the radimate architecture it represent set of classes and interface.

*Hierachy of collection framework:- its diagram given below,
Contain all the classes and interfaces for the collectn framework.

@Major Methods Of Collection Interface:-
-int size();= It Returns total no. of element in the collection.
-boolean IsEmpty();= It check collection is empty or not.
-boolean contains(object);= It check the perticuler elements exist or not in the collections.
-iterator iteratory();= It return the object of iterator through which we can travers in the collections.
-object[] toArray();= It convert collection into array.
-boolean add(object);= Add the new elemnt in the collections.
-boolean remove(object);= Remove the perticuler element from the collections.
-void clear();= Removes all element from the collections.

    *List Interface:-
 Is The child interface in the collection interface in which we can stored ordered collection of object,it can have dublicates values.
list interface is implemented by the classes.List interface is based on index position
classes are:-ArrayList,LinkedList,Vector stack:-It extends the collection interface.

     *Set Interface:-
It represent the unordered set of element,it doesn't allow us to stored the dublicate items,we can store atleast one null value in the
set,set interface is value based.
A Set is a Collection that cannot contain duplicate elements. There are three Predefine classes need to implementations of Set interface
interface: HashSet, TreeSet, and LinkedHashSet. HashSet, which stores its elements in a hash table, is the best-performing implementation;
however it makes no guarantees concerning the order of iteration.TreeSet, which stores its elements in a red-black tree, orders its elements
based on their values; it is substantially slower than HashSet. LinkedHashSet, which is implemented as a hash table with a linked list
running through it, orders its elements based on the order in which they were inserted into the set (insertion-order).

   *Generic class:-
Generic Class provide abstraction over the data types.generic means type safe code is possible.it provide increaseability.
for ex:-List<T> l=new List<T>();
t-type safe.
  
@Extra Additional methods In List Interface:-
-object get(int); =It's used to retrive element of perticuler position.
-object set(int,object);= To set the new element to the given position.
-int indexOf(object);= It Return first occurance position of the element.
-void add(int,object);= Add the new element at perticuler position.
-object remove(int);= Remove the element of the perticuler position.
-List subList(int,int);= Return the sublist of given position, and add new element & remove the last element.

       *ArrayList Class:-
It Uses dynamic array for sorting the element,its like an array but there is no size limit,we can add or remove the element at any time.
it allows the dublicate elements,it implements the list interface.In arraylist whenever we add or remove element at runtime so shifting
of array elem is required so process is time consuming.
      ArrayList is a resizable-array implementation of the List interface. It implements all optional list operations, and permits all
elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the 
array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized). 
ex:-ArrayList,LinkedList.

    *LinkedListClass:-
This Class Uses Doubly Linked List to store the element.it can contain dublicate element.Linkedlist class maintains insertion order.
it's non-synchronize,in linklist manuplation is fast because no need of shifting is required.
add first,add last,remove first,remove last --mtd use in linkedlist class.

   *Vector Class:-
It is like the dynamic array which can grow or shrink its size. Unlike array, we can store n-number of elements in it as there is no size 
limit. It is a part of Java Collection framework since Java 1.2. It is found in the java.util package and implements the List interface,so
 we can use all the methods of List interface   here.It is recommended to use the Vector class in the thread-safe implementation only. If
you don't need to use the thread-safe implementation,you should use the ArrayList, the ArrayList will perform better in such case.
Vector implements List Interface. Like ArrayList it also maintains insertion order but it is rarely used in non-thread environment as
 it is synchronized and due to which it gives poor performance in searching, adding, delete and update of its elements.

The Iterators returned by the Vector class are fail-fast. In case of concurrent modification, it fails and throws the 
ConcurrentModificationException.
It is similar to the ArrayList, but with two differences-
it check in programm size & capacity.
1]Vector is synchronized.
2]Java Vector contains many legacy methods that are not the part of a collections framework.

    *SetInterface:- 
It's inherited from collection interface,set is an unordered collection of object.In set no dublicate element is allowed.it has the same 
method as collection.set interface is implemented in Hashset,LinkedHashset & Treeset classes.
@Treeset:-This class is implements the set interface which uses tree for storage,the object of treeset classes are stored in asscending 
order,treeset class contain unique elements only,it doesnt allow null element.its non synchronized.access and retrival time is fast, some 
new methods of treeset descendingIterator its use to iterate the element in descending order.
i>pollFirst:-It's used to retrive and remove,first or lowest element.
ii>pollLast:-It's used to retrive and remove last element.

   *HashSetClass:- 
It's used to create collection that uses hashtable for storage,it store the element by using the mechanism called hashing.
   It contains unique element only,it allow only one null value,its non synchronized,it doesnt allow insertion order.elements are inserted
on the basis of hash code,its best aproach for search operation.HashSet doesn’t maintain any order, the elements would be returned in any
 random order.The iterator returned by this class is fail-fast which means iterator would throw ConcurrentModificationException if HashSet
has been modified after creation of iterator, by any means except iterator’s own remove method.

    *Linked_Hashset:-
It uses the hashset and linkedhashset contain unique element only,its non synchronized & maintain insertion order.

  *Map Interface:-
Map Interface doesnt extends from collection interface and object.it contain value on the basis of
 key means in key values pair,each
 key and value pair is known as entry.it contains unique keys.It useful if you have to search update,
delete,search element on the basis of key,map interface is implemented in hashmap,treemap,and 
linked hashmap classes.
            A Map is an object that maps keys to values. A map cannot contain duplicate keys. 
  There are three main implementations of Map interfaces: HashMap, TreeMap, and LinkedHashMap.
HashMap: it makes no guarantees concerning the order of iteration
TreeMap: It stores its elements in a red-black tree, orders its elements based on their values; it is substantially slower than HashMap.
LinkedHashMap: It orders its elements based on the order in which they were inserted into the set (insertion-order).


*Major methods of Map Interface:-
-int size();
It return the size of map.
-boolean isEmpty();
It return true if map is empty.
-boolean containsKey(object);
It return true if perticuler value is exist in the map.
-object get(object);
It retrive perticuler element in given key.
-object put(object,object);
Add the new element with key.
-object remove(object);
It Delete perticuler element in given key.
-void putAll(map);
It add the new map object in the existing map object.
-void clear();-It removes all the elements.

*HashMapClass,HashTable:-
 Class stored values in key values pair,values are stored based on the key contains only unique key,
its non synchronized,it maintains no insertion order.
HashMap maintains key and value pairs and often denoted as HashMap<Key, Value> or HashMap<K, V>. HashMap implements Map interface.HashMap
is similar to Hashtable with two exceptions 
– HashMap methods are non synchornized and it allows null key and null values unlike Hashtable. 
It is used for maintaining key and value mapping.It is not an ordered collection which means it does not return the keys and values in 
the same order in which they have been inserted into the HashMap. It neither does any kind of sorting to the stored keys and Values. 
You must need to import java.util.HashMap or its super class in order to use the HashMap class and methods.ex:
/* Display content using Iterator*/
Set set= hmap.entrySet();
Iterator iterator =set.iterator();


 @HashMap:-
Java HashMap contains values based on the key.
Java HashMap contains only unique keys.
Java HashMap may have one null key and multiple null values.
Java HashMap is non synchronized.
Java HashMap maintains no order.

@HashTable:-
A Hashtable is an array of a list. Each list is known as a bucket. The position of 
the bucket is identified by calling the hashcode() 
method. A Hashtable contains values based on the key.
Java Hashtable class contains unique elements.
Java Hashtable class doesn't allow null key or value.
Java Hashtable class is synchronized.

@TreeMap:-
Java TreeMap class is a red-black tree based implementation. It provides an efficient means of storing 
key-value pairs in sorted order.The important points about Java TreeMap classes are:
Java TreeMap contains values based on the key. It implements the NavigableMap interface and extends
 AbstractMap class.
Java TreeMap contains only unique elements.
Java TreeMap cannot have a null key but can have multiple null values.
Java TreeMap is non synchronized.
Java TreeMap maintains ascending order.


*LinkedHashMap is a Hash table and linked list implementation of the Map interface, with predictable inseration order. This implementation
 differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration
 ordering, which is normally the order in which keys were inserted into the map (insertion-order).This class is different from both of them:

•	HashMap doesn’t maintain any order.
•	TreeMap sort the entries in ascending order of keys.
•	LinkedHashMap maintains the insertion order.
*************************************************************************************
Difference Between ArrayList & LinkedList

   -ArrayList                        -LinkedList
i> ArrayList internally uses      i> LinkedList internally uses
  dynamic array to store the         DoublyLinkedList.
  element.
ii> Manipulation of arraylist    ii> Manipulation of LinkedList
    is slow.                         is faster
iii> Arraylist is better for    iii> LinkedList is better for a
    sorting & searching              manipulating a data.
#####################################################################################
         -Set                               -List
i>  Set stored data in unorder    i> List stored the element in
   sequence.                         ordered sequence.
ii>Set doesnt allow to stored    ii> List allow to stored dubli-
   the dublicate value, it           cate values.
   stored unique values.
#####################################################################################
 
Technolearn-->Technolearn---forloop--searng operatn we can perform easily in bytes 099867654 bytes 099867654  means convert string into int format for searching point of view.

hashing add(1)--timing constant
        remove(1)--constant time
        search--contains(1)---constant time thats why hashing is best technique for search.
  